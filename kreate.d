module kreate;

import std.stdio;
import std.algorithm;
import std.datetime.systime;
import std.datetime.timezone;
import core.time;
import core.stdc.stdlib;
import std.string;
import std.array;
import std.file;
import std.digest.md;
import std.conv;
import std.path;
import std.process;

/// main project structure, you never have to interact with it, it is managed by kreate
struct Project {
    string name;
    string ver;
    string buildDir;
    string binDir;
    string[] targetLangs;
    string[] cliArgs;
}

/// the instance of @Project managed by create
Project projectConfig = Project(null);

struct Lang {
    string name;
    string[] extensions;
}

enum TargetType {
    EXECUTABLE,
    STATIC_LIB,
    DYNAMIC_LIB,
    CUSTOM,
}

struct Target {
    string name;
    string[] sourceFiles;
    TargetType targetType;
    string outputFile;
    Target[] dependencies;
    string[] flags;
    string customCommand;
    string mainDir;
    string[] importPaths;
}

Target[] targets;

const auto go = Lang("go", [".go"]);
const auto d = Lang("d", [".d"]);
const auto odin = Lang("odin", [".odin"]);

Lang[] supported = [go, d, odin];

struct Log {
    static const string infoCol = "\x1B[38;5;87m";
    static const string warnCol = "\x1B[38;5;214m";
    static const string erroCol = "\x1B[38;5;196m";
    static const string fataCol = "\x1B[38;5;202m";
    static const string reset = "\x1B[0m";

    /// make this noop for now
    static string timestamp() {
        auto now = Clock.currTime();
        // return now.toString();
        return "";
    }

    static void info(string msg) {
        writeln(timestamp(), infoCol, " [INFO] ", reset, msg);
    }

    static void warn(string msg) {
        writeln(timestamp(), warnCol, " [WARN] ", reset, msg);
    }

    static void error(string msg) {
        writeln(timestamp(), erroCol, " [ERRO] ", reset, msg);
    }

    static void fatal(string msg) {
        writeln(timestamp(), fataCol, " [FATA] ", reset, msg);
        exit(1);
    }
}

void k_mkdir(string path) {
    if (!exists(path)) {
        mkdir(path);
    }
}

/// drops a * gitignore into a directory, this is a trick from meson,
/// the gitignore ignored the whole directory from within itself so it's never included with no external gitignores
void dropKreateGitignore(string path) {
    string gitignore = "# This file is autogenerated by kreate, any edits will be overwritten!\n*";
    std.file.write(path ~ "/.gitignore", gitignore);
}

void project(string name,
    string ver,
    string[] targetLangs,
    string[] args = null,
    string buildDir = "build",
    string binDir = "bin"
) {
    if (projectConfig != Project(null)) {
        Log.fatal("project can only be called once in a kreate build system\n 
        ℹ️  If you are trying to add build targets use: staticLib(), dynamicLib(), executable(), customTarget()");
    }

    auto unsupported = targetLangs.filter!(
        targetLang =>
            !supported.canFind!(lang => lang.name == targetLang)
    ).array;

    if (unsupported.length > 0) {
        string langList;
        foreach (lang; unsupported) {
            langList ~= "  - " ~ lang ~ "\n";
        }
        Log.fatal(format("use of an unsupported language(s):\n%s
        ℹ️  If you want to use an unsupported language, you need to create a custom target: customTarget()",
                langList));
    }

    k_mkdir(buildDir);
    dropKreateGitignore(buildDir);
    k_mkdir(binDir);
    dropKreateGitignore(binDir);

    projectConfig = Project(name = name,
        ver,
        buildDir,
        binDir,
        targetLangs,
        args
    );
}

/// utils for finding singular args
bool hasArg(string command) {
    foreach (arg; projectConfig.cliArgs) {
        if (arg == command)
            return true;
    }
    return false;
}

bool hasSubcommand(string command) {
    return projectConfig.cliArgs[1] == command;
}

struct FileChecksum {
    string filePath;
    string checksum;
    SysTime lastModified;
}

FileChecksum calculateChecksum(string filePath) {
    ubyte[] content = cast(ubyte[]) std.file.read(filePath);

    auto md5 = new MD5Digest();
    auto hash = md5.digest(content);
    string checksum = toHexString(hash).dup;

    SysTime lastModified = std.file.timeLastModified(filePath);

    return FileChecksum(filePath, checksum, lastModified);
}

void saveChecksum(FileChecksum checksum, string buildDir) {
    string checksumDir = buildDir ~ "/checksums";
    k_mkdir(checksumDir);

    string checksumPath = checksumDir ~ "/" ~ std.path.baseName(checksum.filePath) ~ ".#";

    std.file.write(checksumPath, checksum.filePath ~ "\n" ~ checksum.checksum ~ "\n" ~
            checksum.lastModified.toString());
}

FileChecksum loadChecksum(string filePath, string buildDir) {
    string checksumDir = buildDir ~ "/checksums";
    string checksumPath = checksumDir ~ "/" ~ std.path.baseName(filePath) ~ ".#";

    if (!std.file.exists(checksumPath)) {
        return FileChecksum("", "", SysTime.init);
    }

    string[] lines = std.file.readText(checksumPath).splitLines();
    if (lines.length < 3) {
        return FileChecksum("", "", SysTime.init);
    }

    SysTime lastModified;
    try {
        lastModified = SysTime.fromISOExtString(lines[2]);
    } catch (Exception e) {
        lastModified = SysTime.init;
    }

    return FileChecksum(lines[0], lines[1], lastModified);
}

bool needsRebuild(string filePath, string buildDir) {
    if (hasArg("-f") | hasArg("--force"))
        return true;

    FileChecksum oldChecksum = loadChecksum(filePath, buildDir);
    FileChecksum newChecksum = calculateChecksum(filePath);

    return oldChecksum.checksum != newChecksum.checksum;
}

bool executeBuildCommand(Target target) {
    string cmd;
    string lang = detectLanguage(target.sourceFiles);

    if (target.targetType == TargetType.CUSTOM) {
        cmd = target.customCommand;
    } else if (lang == "d") {
        cmd = buildDCommand(target);
    } else if (lang == "go") {
        cmd = buildGoCommand(target);
    } else if (lang == "odin") {
        cmd = buildOdinCommand(target);
    } else {
        Log.fatal("Unsupported language: " ~ lang);
        return false;
    }

    Log.info("Executing: " ~ cmd);
    auto result = executeShell(cmd);
    if (result.status != 0) {
        Log.error("Build failed: " ~ result.output);
        return false;
    }

    Log.info("Build successful, for target: " ~ target.name);
    return true;
}

string buildDCommand(Target target) {
    string cmd = "dmd ";

    if (target.flags.length > 0) {
        cmd ~= join(target.flags, " ") ~ " ";
    }

    if (target.targetType == TargetType.STATIC_LIB) {
        cmd ~= "-lib ";
    } else if (target.targetType == TargetType.DYNAMIC_LIB) {
        cmd ~= "-shared ";
    }

    cmd ~= "-of=" ~ target.outputFile ~ " ";

    cmd ~= join(target.sourceFiles, " ") ~ " ";

    foreach (dep; target.dependencies) {
        if (dep.targetType == TargetType.STATIC_LIB || dep.targetType == TargetType.DYNAMIC_LIB) {

            cmd ~= "-L-L" ~ dirName(dep.outputFile) ~ " ";

            string libName = baseName(dep.outputFile);

            if (libName.startsWith("lib")) {
                libName = libName[3 .. $];
            }

            libName = stripExtension(libName);

            cmd ~= "-L-l" ~ libName ~ " ";
        }
    }

    return cmd;
}

/// use -C to simplify package detection
string buildGoCommand(Target target) {
    string mainDir = inferMainDir(target.sourceFiles);

    string cmd = "go build ";

    cmd ~= "-C " ~ mainDir ~ " ";

    if (target.flags.length > 0) {
        cmd ~= join(target.flags, " ") ~ " ";
    }

    if (target.targetType == TargetType.DYNAMIC_LIB) {
        cmd ~= "-buildmode=c-shared ";
    } else if (target.targetType == TargetType.STATIC_LIB) {
        cmd ~= "-buildmode=c-archive";
    }

    auto absOutput = asNormalizedPath(asAbsolutePath(target.outputFile));

    cmd ~= "-o " ~ absOutput.array ~ " ";

    cmd ~= ".";

    return cmd;
}

string buildOdinCommand(Target target) {
    string mainDir = inferMainDir(target.sourceFiles);

    string cmd = "odin build ";

    cmd ~= mainDir ~ " ";

    if (target.flags.length > 0) {
        cmd ~= join(target.flags, " ") ~ " ";
    }

    if (target.targetType == TargetType.STATIC_LIB) {
        cmd ~= "-build-mode:static ";
    } else if (target.targetType == TargetType.DYNAMIC_LIB) {
        cmd ~= "-build-mode:shared ";
    }

    cmd ~= "-out:" ~ target.outputFile ~ " ";

    foreach (dep; target.dependencies) {
        if (dep.targetType == TargetType.STATIC_LIB) {
            cmd ~= "-library:" ~ dep.outputFile ~ " ";
        }
    }

    return cmd;
}

string inferMainDir(string[] sourceFiles) {
    if (sourceFiles.length == 0) {
        return ".";
    }

    // needs better detection here, but for now it's fine
    return dirName(sourceFiles[0]);
}

string detectLanguage(string[] sourceFiles) {
    if (sourceFiles.length == 0) {
        Log.fatal("No source files specified");
    }

    string ext = std.path.extension(sourceFiles[0]);

    foreach (lang; supported) {
        if (lang.extensions.canFind(ext)) {
            if (projectConfig.targetLangs.canFind(lang.name)) {
                return lang.name;
            }
        }
    }

    auto name = replace(ext, ".", "");

    Log.fatal("Unsupported or not enabled language detected: " ~ name);
    return ""; // doesn't matter what we return since Log.fatal exits either way
}

bool buildTarget(ref Target target) {
    if (!needsRebuildTarget(target)) {
        Log.info("Target " ~ target.name ~ " is up to date");
        return true;
    }

    Log.info("Building target: " ~ target.name);

    foreach (ref dependency; target.dependencies) {
        if (!buildTarget(dependency)) {
            Log.error("Failed to build dependency: " ~ dependency.name);
            return false;
        }
    }

    string outputDir = dirName(target.outputFile);
    k_mkdir(outputDir);

    if (!executeBuildCommand(target)) {
        return false;
    }

    foreach (sourceFile; target.sourceFiles) {
        auto checksum = calculateChecksum(sourceFile);
        saveChecksum(checksum, projectConfig.buildDir);
    }

    return true;
}

bool needsRebuildTarget(ref Target target) {
    string buildDir = projectConfig.buildDir;

    if (!std.file.exists(target.outputFile)) {
        return true;
    }

    foreach (sourceFile; target.sourceFiles) {
        if (needsRebuild(sourceFile, buildDir)) {
            return true;
        }
    }

    foreach (ref dependency; target.dependencies) {
        if (needsRebuildTarget(dependency)) {
            return true;
        }
    }

    return false;
}

Target executable(string name, string[] sourceFiles, Target[] dependencies = [], string[] importPaths = [
    ]) {
    string outputFile = projectConfig.binDir ~ "/" ~ name;
    version (Windows) {
        outputFile ~= ".exe";
    }

    string lang = detectLanguage(sourceFiles);
    string[] flags;

    if (lang == "d") {
        flags = ["-O", "-release"];
    } else if (lang == "go") {
        flags = ["-ldflags", "\"-s -w\""];
    } else if (lang == "odin") {
        flags = ["-o:speed"];
    }

    string mainDir = inferMainDir(sourceFiles);

    Target target = Target(
        name,
        sourceFiles,
        TargetType.EXECUTABLE,
        outputFile,
        dependencies,
        flags,
        "",
        mainDir,
        importPaths
    );

    targets ~= target;
    return target;
}

Target staticLib(string name, string[] sourceFiles, Target[] dependencies = [], string[] importPaths = [
    ]) {
    string outputFile = projectConfig.buildDir ~ "/lib" ~ name ~ ".a";

    string lang = detectLanguage(sourceFiles);
    string[] flags;

    if (lang == "d") {
        flags = ["-O", "-release"];
    } else if (lang == "go") {
        flags = ["-ldflags", "\"-s -w\""];
    } else if (lang == "odin") {
        flags = ["-o:speed"];
    }

    string mainDir = inferMainDir(sourceFiles);

    Target target = Target(
        name,
        sourceFiles,
        TargetType.STATIC_LIB,
        outputFile,
        dependencies,
        flags,
        "",
        mainDir,
        importPaths
    );

    targets ~= target;
    return target;
}

Target dynamicLib(string name,
    string[] sourceFiles,
    Target[] dependencies = [],
    string[] importPaths = []
) {
    string outputFile;
    version (Windows) {
        outputFile = projectConfig.buildDir ~ "/" ~ name ~ ".dll";
    } else version (OSX) {
        outputFile = projectConfig.buildDir ~ "/lib" ~ name ~ ".dylib";
    } else {
        outputFile = projectConfig.buildDir ~ "/lib" ~ name ~ ".so";
    }

    string lang = detectLanguage(sourceFiles);
    string[] flags;

    if (lang == "d") {
        flags = ["-O", "-release"];
    } else if (lang == "go") {
        flags = ["-ldflags", "\"-s -w\""];
    } else if (lang == "odin") {
        flags = ["-o:speed"];
    }

    string mainDir = inferMainDir(sourceFiles);

    Target target = Target(
        name,
        sourceFiles,
        TargetType.DYNAMIC_LIB,
        outputFile,
        dependencies,
        flags,
        "",
        mainDir,
        importPaths
    );

    targets ~= target;
    return target;
}

/// use to specify any custom target, kreate still manages it and builds it incrementally,
/// a custom target can still be used as a dependency for other targets
Target customTarget(string name,
    string[] sourceFiles,
    string outputFile,
    string customCommand,
    Target[] dependencies = []) {
    Target target = Target(
        name,
        sourceFiles,
        TargetType.CUSTOM,
        outputFile,
        dependencies,
        [],
        customCommand,
        inferMainDir(sourceFiles),
        []
    );

    targets ~= target;
    return target;
}

/// executes the build of all targets or the onse that are passed in
void kreateBuild(string[] targetNames = []) {
    if (targetNames.length == 0) {
        foreach (ref target; targets) {
            if (!buildTarget(target)) {
                Log.fatal("Build failed for target: " ~ target.name);
            }
        }
    } else {
        foreach (targetName; targetNames) {
            bool found = false;
            foreach (ref target; targets) {
                if (target.name == targetName) {
                    if (!buildTarget(target)) {
                        Log.fatal("Build failed for target: " ~ targetName);
                    }
                    found = true;
                    break;
                }
            }

            if (!found) {
                Log.fatal("Target not found: " ~ targetName);
            }
        }
    }

    Log.info("Build completed successfully");
}

/// removes the configured bin and build directories and everything in them including kreate checksums 
void kreateClean() {
    if (std.file.exists(projectConfig.buildDir)) {
        std.file.rmdirRecurse(projectConfig.buildDir);
        Log.info("Removed build directory: " ~ projectConfig.buildDir);
    }

    if (std.file.exists(projectConfig.binDir)) {
        std.file.rmdirRecurse(projectConfig.binDir);
        Log.info("Removed bin directory: " ~ projectConfig.binDir);
    }

    Log.info("Clean completed successfully");
}

/// initializes and registers the kreate build system for execution
void kreateInit() {
    if (projectConfig.cliArgs.length > 1) {
        if (hasSubcommand("build")) {
            kreateBuild();
            return;
        }
        if (hasSubcommand("clean")) {
            kreateClean();
            return;
        }
    }

    Log.warn("cli arguments not forwarded to kreate, executing default build
    
        you can customize this behaviour by using the operation functions in your build script: kreateBuild(), ...
        or by forwarding cli arguments to the kreate project() function
    ");

    kreateBuild();
}
